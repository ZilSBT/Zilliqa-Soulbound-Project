(* SPDX-License-Identifier: MIT *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils ListUtils IntUtils
library SoulBoundToken

type Operation =
| Add
| Sub

(* Global variables *)
let zero_address = 0x0000000000000000000000000000000000000000
let false = False
let true = True
let zero = Uint256 0
let one = Uint256 1
let empty_string = ""

let add_operation = Add
let sub_operation = Sub
let min_fee_bps = Uint128 1
let max_fee_bps = Uint128 10000

(* Library functions *)
let one_msg = 
  fun (msg: Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1: Message) =>
  fun (msg2: Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (maybe_bal: Option Uint256) =>
    match maybe_bal with
    | None => zero
    | Some bal => bal
    end

(* Error exception *)
type Error =
  | NotPausedError
  | PausedError
  | SelfError
  | NotContractOwnerError
  | NotContractOwnershipRecipientError
  | NotTokenOwnerError
  | NotMinterError
  | NotOwnerOrOperatorError
  | MinterNotFoundError
  | MinterFoundError
  | SpenderFoundError
  | OperatorNotFoundError
  | OperatorFoundError
  | NotAllowedToTransferError
  | TokenNotFoundError
  | InvalidFeeBPSError
  | ZeroAddressDestinationError
  | ThisAddressDestinationError
  | MoreThanOneTokenError

let make_error =
  fun (result: Error) =>
    let result_code = 
      match result with
      | NotPausedError                     => Int32 -1
      | PausedError                        => Int32 -2
      | SelfError                          => Int32 -3
      | NotContractOwnerError              => Int32 -4
      | NotTokenOwnerError                 => Int32 -5
      | NotMinterError                     => Int32 -6
      | NotOwnerOrOperatorError            => Int32 -7
      | MinterNotFoundError                => Int32 -8
      | MinterFoundError                   => Int32 -9
      | SpenderFoundError                  => Int32 -10
      | OperatorNotFoundError              => Int32 -11
      | OperatorFoundError                 => Int32 -12
      | NotAllowedToTransferError          => Int32 -13
      | TokenNotFoundError                 => Int32 -14
      | InvalidFeeBPSError                 => Int32 -15
      | ZeroAddressDestinationError        => Int32 -16
      | ThisAddressDestinationError        => Int32 -17
      | NotContractOwnershipRecipientError => Int32 -18
      | MoreThanOneTokenError              => Int32 -19
      end
    in
    { _exception: "Error"; code: result_code }


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SoulBoundToken
(
  initial_contract_owner: ByStr20,
  initial_base_uri: String, (*website *)
  name: String,
  symbol: String
)

(* Contract constraints *)
with
  (* `initial_contract_owner` must not be the zero address *)
  let is_contract_owner_invalid = builtin eq initial_contract_owner zero_address in
  (* `name` must not be an empty string *)
  let is_name_invalid = builtin eq name empty_string in
  (* `symbol` must not be an empty string *)
  let is_symbol_invalid = builtin eq symbol empty_string in
  (* Check if any parameter is invalid *)
  let is_name_or_symbol_invalid = orb is_name_invalid is_symbol_invalid in

  let is_invalid = orb is_contract_owner_invalid is_name_or_symbol_invalid in
  negb is_invalid
=>

procedure UpdateBalance(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    maybe_count <- balances[address];
    new_count = 
      let cur_count = get_bal maybe_count in
      (* if overflow occurs, it throws CALL_CONTRACT_FAILED *)
      builtin add cur_count one;
    balances[address] := new_count
  | Sub =>
    maybe_count <- balances[address];
    new_count = 
      let cur_count = get_bal maybe_count in
      (* if underflow occurs, it throws CALL_CONTRACT_FAILED *)
      builtin sub cur_count one;
    balances[address] := new_count
  end
end

procedure IsMinter(address: ByStr20)
has_minter <- exists minters[address];
match has_minter with
  | True =>
  | False =>
    error = NotMinterError;
    Throw error
  end
end

procedure RequireValidDestination(to: ByStr20)
  (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
  is_zero_address = builtin eq to zero_address;
  match is_zero_address with
  | False =>
  | True =>
    error = ZeroAddressDestinationError;
    Throw error
  end
end

procedure HasToken(to: ByStr20)
  tokenbalance <- balances[to];
  balance = get_bal tokenbalance;
  owns_token = builtin eq balance zero;
  match owns_token with
  | False => 
    error = MoreThanOneTokenError;
    Throw error
    | True =>
    (* noop *)
  end
end


(* @Requirements: *)
(* - `to` must not be the zero address. Otherwise, it must throw `ZeroAddressDestinationError` *)
(* - `_sender` must be a minter. Otherwise, it must throw `NotMinterError` *)
procedure MintToken(to: ByStr20)
  RequireValidDestination to;

  HasToken to;

  IsMinter _sender;

  (* generate ID *)
  current_token_id_count <- token_id_count;
  new_token_id_count = builtin add current_token_id_count one; 
  token_id_count := new_token_id_count;
  token_id = new_token_id_count;

  (* mint a new token *)
  token_owners[token_id] := to;

  (* add one to the token owner balance *)
  UpdateBalance add_operation to;
  
  (* add one to the total supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply
end

(* Mints a token with a specific `token_uri` and transfers it to `to`. *)
(* Pass empty string to `token_uri` to use the concatenated token URI. i.e. `<base_uri><token_id>`. *)
(* @param: to - Address of the token recipient *)
(* @param: token_uri - URI of a token *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw `PausedError` *)
transition Mint(to: ByStr20, token_uri: String)
  (* RequireNotPaused;  *)
  
  MintToken to; 
  token_id <- token_id_count;
  SetTokenURI token_id token_uri;

  e = {
    _eventname: "Mint";
    to: to;
    token_id: token_id;
    token_uri: token_uri
  };
  event e;
  msg_to_recipient = {
    _tag: "ZSBT_RecipientAcceptMint";
    _recipient: to;
    _amount: Uint128 0
  };
  msg_to_sender = {
    _tag: "ZSBT_MintCallback";
    _recipient: _sender;
    _amount: Uint128 0;
    to: to;
    token_id: token_id;
    token_uri: token_uri
  };
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end



